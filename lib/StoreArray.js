'use strict';

var utils = require('./utils');
var getIds = utils.getIds;

module.exports = StoreArray;

// assign all properties to target except those whose name starts with an underscore
function _assign( target, props ) {
    var underscore = '_'.charCodeAt(0);
    for (var k in props) if (k.charCodeAt(0) !== underscore) target[k] = props[k];
    return target;
}

// return a Date ms milliseconds from now (or ms ago if negative)
function timestamp( ms ) {
    var ts = new Date(utils.getNewerTimestamp(0));
    ts.setMilliseconds(ts.getMilliseconds() + ms);
    return ts;
}

function StoreArray( options ) {
    if (!(this instanceof StoreArray)) return new StoreArray(options);
    options = options || {};
    var sysid = this.sysid = options.sysid || '-mque-';
    this.getIds = options.getIds || function(count) { return getIds(sysid, count) };

    // waiting jobs are locked by '' no-one
    this.noLock = '';
    this.lockDurationMs = 120000;
    // done jobs are locked by '__done' and are dated after year 5000
    this.doneLock = '__done';
    this.doneDtOffsetMs = new Date('1000-01-01 00:00:00.000Z').getTime();

    this.jobs = [];
    this.handlers = {};
}

StoreArray.prototype.setHandler = function setHandler(jobtype, context, handler) {
    this.handlers[jobtype] = { context: context, handler: handler };
}
StoreArray.prototype.getHandler = function getHandler(jobtype) {
    return this.handlers[jobtype];
}
StoreArray.prototype.deleteHandler = function deleteHandler(jobtype) {
    this.handlers[jobtype] = undefined;
}

StoreArray.prototype.getJobtypes = function getJobtypes( callback ) {
    var now = timestamp(0);
    var noLock = this.noLock;
    var types = {};
    function filter(job) {
        if (job.lock === noLock && job.dt <= now) {
            types[job.type] = types[job.type] ? types[job.type] + 1 : 1;
        }
    }
    this._filterJobs(filter, {});
    callback(null, types);
}
StoreArray.prototype.getAllJobtypes = function getAllJobtypes( callback ) {
    var types = {};
    for (var i = 0; i < this.jobs.length; i++) {
        var type = this.jobs[i].type;
        types[type] = types[type] ? types[type] + 1 : 1;
    }
    callback(null, types);
}
// FIXME: need to push job objects, not just the payloads -- want ids generated by the journal (for timestamp)
StoreArray.prototype.addJobs = function addJobs( type, payloads, options, callback ) {
    if (typeof options === 'function') { callback = options; options = {} }
    var ids = this.getIds(payloads.length);
    var runWhen = new Date(utils.getNewerTimestamp(0) + (options.delayMs || 0));
    for (var i = 0; i < payloads.length; i++) {
        this.jobs.push({
            id: ids[i],
            type: type,
            dt: runWhen,
            lock: this.noLock,
            data: payloads[i],
        });
    }
    callback(null, ids);
}
StoreArray.prototype._filterJobs = function _filterJobs( filterFn, options ) {
    options = _assign({ fetch: false, keep: true, limit: Infinity }, options);
    var selectedJobs = options.fetch ? [] : null;
    var recompact = !options.keep;

    for (var i = 0, j = 0, foundCount = 0; i < this.jobs.length; i++) {
        var job = this.jobs[i];
        var match = foundCount < options.limit && filterFn(job);
        if (match) {
            foundCount++;
            if (selectedJobs) selectedJobs.push(job);
        }
        else if (recompact && j !== i) {
            this.jobs[j++] = job;
        }
    }

    // trim array if we were compacting and some jobs were removed
    if (recompact && foundCount > 0) this.jobs.length -= foundCount;

    return selectedJobs || foundCount;
}
StoreArray.prototype._updateJobs = function _updateJobs( ids, lock, props, options ) {
    var select = typeof ids === 'function' ? ids : function(job) { return job.lock === lock && ids.indexOf(job.id) >= 0 };
    var filter = function(job) {
        if (select(job)) {
            _assign(job, props);
            if (props._dtDelta) job.dt = new Date(job.dt + props._dtDelta);
            return true;
        }
    };
    return this._filterJobs(filter, options);
}
StoreArray.prototype.getJobs = function getJobs( type, limit, lock, callback ) {
    limit = typeof limit === undefined ? Infinity : limit;
    var now = timestamp(0);
    var noLock = this.noLock;
    var filter = function(job) { return job.type === type && job.lock === noLock && job.dt >= now };
    var jobs = this._updateJobs(filter, null, { dt: timestamp(this.lockDurationMs), lock: lock }, { limit: limit });
    // the payload is already attached to the job
    callback(null, jobs);
}
// release, requeue, re-lock or archive jobs
//   release: deltaMs = -N, newLock = ''
//   requeue: deltaMs = 0, newLock = ''
//   re-lock: deltaMs = N, newLock = lock
//   archive: deltaMs = +1000 years, newLock = '__done'
//   to suspend, add +5000 years to job.dt but leave the lock empty
StoreArray.prototype.ungetJobs = function ungetJobs( ids, lock, callback ) {
    callback(null, this._updateJobs(ids, lock, { lock: this.noLock, dt: timestamp(-this.lockDurationMs) }));
}
StoreArray.prototype.retryJobs = function retryJobs( ids, lock, delayMs, callback ) {
    callback(null, this._updateJobs(ids, lock, { dt: timestamp(delayMs), lock: this.noLock }));
}
StoreArray.prototype.renewJobs = function renewJobs( ids, lock, callback ) {
    callback(null, this._updateJobs(ids, lock, { dt: timestamp(this.lockDurationMs) }));
}
StoreArray.prototype.doneJobs = function doneJobs( ids, lock, callback ) {
    callback(null, this._updateJobs(ids, lock, { lock: this.doneLock, _dtDelta: this.doneDtOffsetMs }));
}
StoreArray.prototype.deleteJobs = function deleteJobs( ids, lock, callback ) {
    var removed = this._updateJobs(ids, lock, {}, { fetch: true, keep: false });
    callback(null, ids);
}
StoreArray.prototype.expireLocks = function expireLocks( now, callback ) {
    var noLock = this.noLock;
    this._filterJobs(function(job) {
        if (job.lock !== noLock && job.dt < now) {
            job.lock = noLock;
            job.dt = now;
        }
    })
    callback();
}
StoreArray.prototype = toStruct(StoreArray.prototype);
function toStruct(hash) { return toStruct.prototype = hash }
